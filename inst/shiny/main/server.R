shinyServer(function(input, output, session) {
  values <- reactiveValues(nGlobalParameters = 1, nEquation = 0, nRgho = 0, nSurvival = 0, 
                           nTimedep = 0, nDeterministic = 0, nProbabilistic = 0, moduleEdit = FALSE)
  local_values <- reactiveValues(restoring = 0, restoring_time = Sys.time(), restore_final = FALSE)
  
  onBookmark(function(state) {
    nameValues <- names(reactiveValuesToList(values))
    walk(nameValues, function(x){
      state$values[[x]] <- values[[x]]
    })
  })
  
  onRestore(function(state) {
    nameValues <- ls(state$values)
    walk(nameValues, function(x){
      values[[x]] <- state$values[[x]]
    })
    local_values$last_tab <- input$main
    
  })
  
  onRestored(function(state) {
    output_names <- names(outputOptions(output))
    output_names <- output_names[-grep("debug", output_names)]
    except <- c(MODULES, "DSA", "DSAtable")
    output_names <- output_names[!output_names %in% except]
    for (out in output_names){
      outputOptions(output, out, suspendWhenHidden = FALSE)
    }
    local_values$restoring <- 1
    local_values$restoring_time <- Sys.time()
  })
  
  observe({
    if (local_values$restoring == 1){
      invalidateLater(1000)
      if (Sys.time() - local_values$restoring_time > 2){
        updateTabItems(session, "main", "tab_global_parameters" )

        local_values$restoring <- 2
        local_values$restoring_time <- Sys.time()
      }
    }
  })
  observe({
    if (local_values$restoring == 2){
      invalidateLater(1000)
      if (Sys.time() - local_values$restoring_time > 2){
        updateTabItems(session, "main", "tab_dsa" )
        local_values$restoring <- 3
        local_values$restoring_time <- Sys.time()
      }
    }
  })
  observe({
    if (local_values$restoring == 3){
      invalidateLater(1000)
      if (Sys.time() - local_values$restoring_time > 2){
        updateTabItems(session, "main", local_values$last_tab )
        local_values$restoring <- 4
        local_values$restoring_time <- Sys.time()
      }
    }
  })
  
  observe({
    if(local_values$restoring == FINAL_RESTORE | local_values$restoring  == 0) {
      local_values$restore_final <- TRUE
    } else local_values$restore_final <- FALSE
  })
  
  output$masker <- renderUI({
    if(!local_values$restore_final){
      tagList(
      div(style = "width:100%; position:relative; background-color:#ecf0f5; z-index:2; display:flex; justify-content:center",
          div("Restoring...", icon("refresh", class = "fa-spin fa-2x"))
      ),
      div(style = "width:100%; height:1000px;position:absolute; background-color:#ecf0f5; z-index:2000"
      )
      )
    }
  })
  
  observe({
    if(!local_values$restore_final){
      hide("main")
    } else shinyjs::show("main")
  })

  setBookmarkExclude(
    c(
      paste0(MODULES, "OK"),
      "newParam",
      unname(MODULES),
      "addDeterministic",
      "addProbabilistic"
    )
  )
  
  observe({ ##?WHY??
  output$searchCountry <- renderUI({
    n <- values$nRho
    req(input[[paste0("rghoRegion", n)]])
    countryCodes <- filter_gho(
      COUNTRY,
      WHO_REGION_CODE == input[[paste0("rghoRegion", n)]]
    )
    countryNames <- countryCodes %>%
      attr("labels")
    
    vCountryCodes <- as.vector(c("Global", countryCodes))
    names(vCountryCodes) <- c("Global", countryNames)
    
    selectizeInput(
      paste0("rghoCountry", n),
      NULL,
      choices = vCountryCodes,
      selected = ifelse(!is.null(input[[paste0("rghoCountry", n)]]), input[[paste0("rghoCountry", n)]], "GLOBAL")
    )
  })
  })
  
  observe_timedepNew <- list()
  
  observe_nTimedep <<- observe({
    lapply(0:values$nTimedep, function(n){
      isolate({
        if (map_lgl(observe_timedepNew[n + 1], is.null)){ #I would have prefered : if (is.null(observe_timedepNew[[n+1]]))
          observe_timedepNew[[n + 1]] <<- observeEvent(input[[paste0("timedepNew", n)]], {
            if (is.null(values[[paste0("nTimedepNC", n)]]))
              values[[paste0("nTimedepNC", n)]] <- 1
            else 
              values[[paste0("nTimedepNC", n)]] <- values[[paste0("nTimedepNC", n)]] + 1
          })
        }
      })
    })
  }) 


  observe({
    inFile <- input$loadButton
    if (is.null(inFile))
      return(NULL)
    else {
      load(inFile$datapath)
      updateNumericInput(session, "nbStates", value = input$nbStates)
      updateNumericInput(session, "nbStateVariables", value = input$nbStateVariables)
      updateNumericInput(session, "nbStrategies", value = input$nbStrategies)
      updateCheckboxInput(session, "use_morta", value = input$use_morta)
      updateNumericInput(session, "startAge", value = input$startAge)
      updateNumericInput(session, "cycleLength", value = input$cycleLength)
      updateRadioButtons(session, "gender", selected = input$gender)
      updateSelectInput(session,"countMethod", selected = input$countMethod)
      updateNumericInput(session, "cycles", value = input$cycles)
    }
  })
  
  output$saveButton <- downloadHandler(
    filename = function() {
      paste0('data-', Sys.Date(), '.RData')
    },
    content = function(file) {
      save(input, values, file=file)
    }
  )
  
  output$nameStates <- renderUI({
    req(input$nbStates)
    lapply(
      seq_len(input$nbStates),
      function(i) {
        isolate({
          textInput(
            paste0("stateName", i),
            paste("State Name", i),
            value = ifelse(
              !is.null(input[[paste0("stateName",i)]]),
              input[[paste0("stateName",i)]],
              LETTERS[i]))
        })
      }) %>% box
  })
  
  output$nameStateVariables <- renderUI({
    req(input$nbStateVariables)

    lapply(
      seq_len(input$nbStateVariables),
      function(i) {
        isolate({
          textInput(
            paste0("variableStateName", i),
            paste("Variable Name", i),
            value = ifelse(
              !is.null(input[[paste0("variableStateName",i)]]),
              input[[paste0("variableStateName",i)]],
              if (i == 1)
                "cost"
              else if (i==2)
                "outcome"
              else
                paste0("variable_",i)))
        })
      }) 
  })
  
  output$nameStrategies <- renderUI({
    req(input$nbStrategies)
    
    lapply(
      seq_len(input$nbStrategies),
      function(i) {
        isolate({
          textInput(
            paste0("strategyName", i),
            paste("Strategy Name", i),
            value = ifelse(
              !is.null(input[[paste0("strategyName",i)]]),
              input[[paste0("strategyName",i)]],
              as.character(as.roman(i))))
        })
      }) %>% box
  })
  
  
  output$transMatrix1 <- renderUI({
    show_first(val = "TM1", FUN = showTransMatrix, input)    
  })
  
  output$transMatrix2 <- renderUI({
    show_next(val = "TM2", trigger = "copyValuesParametersTM", input, values, showTransMatrix)
    
  })  
  
  output$stateParameters1 <- renderUI({
    req(input[[paste0("variableStateName", input$nbStateVariables)]])
    show_first(val = "SP1", FUN = showStateParam, input)
  })
  
  output$stateParameters2 <- renderUI({
    req(input[[paste0("variableStateName", input$nbStateVariables)]])
    show_next(val = "SP2", trigger = "copyValuesParametersSP", input, values, showStateParam)
  })
  
  
  
  output$costVariable <- renderUI({
    textInput(
      "costVariable",
      label = "Cost Variable",
      value = input$variableStateName1
    )
  })
  output$effectVariable <- renderUI({
    textInput(
      "effectVariable",
      label = "Effect Variable",
      value = input$variableStateName2
    )
  })
  
  observeEvent(input$addParametersGP, {
    isolate(values$nGlobalParameters <- values$nGlobalParameters + 1)
  })
  
  output$DSA <- renderUI({
    req(sum(c(values$nEquation, values$nRgho, values$nSurvival, values$nTimedep)) > 0)
    # choices <- get_names_SA(input, values)
    # req(length(choices) > 0)
    i = 0
    tagList(
    column(12,
           uiOutput("DSAtable")
           )
      ,
    column(12,
    div(class="centerdiv",
        actionButton("addDeterministic", "Add a deterministic value")
    ))
    )
  })

  observeEvent(input$addDeterministic, {
    values$nDeterministic <- values$nDeterministic + 1
  })

  output$DSAtable <- renderUI({
    req(sum(c(values$nEquation, values$nRgho, values$nSurvival, values$nTimedep)) > 0)
    choices <- get_names_SA(input, values)
    req(length(choices) > 0)
    lapply(0:values$nDeterministic, function(i){
      show_DSA_div(input, values, choices, i)
    })
  })

  add_probabilistic <- NULL
  
  # output$PSA <- renderUI({
  #   req(sum(c(values$nEquation, values$nRgho, values$nSurvival, values$nTimedep)) > 0)
  #   isolate(choices <- get_names_SA(input, values))
  #   req(length(choices) > 0)
  # 
  #   i = 0
  #   tagList(
  #     column(12,
  #            uiOutput("PSAtable")
  #     ),
  #     column(12,
  #            div(class="centerdiv",
  #                actionButton("addProbabilistic", "Add a probabilistic value")
  #            ))
  #   )
  # })
  
  # output$PSAtable <- renderUI({
  #   req(sum(c(values$nEquation, values$nRgho, values$nSurvival, values$nTimedep)) > 0)
  #   isolate(choices <- get_names_SA(input, values))
  #   req(length(choices) > 0)
  #   lapply(0:values$nProbabilistic, function(i){
  #     show_PSA_div(input, values, choices, i)
  #   })
  # })
  
    observeEvent(input$addProbabilistic, {
    values$nProbabilistic <- values$nProbabilistic + 1
    
  })
    
  # output$addMultinomial <- renderUI({
  #   req(values$nProbabilistic > 0)
  #   isolate(choices <- get_names_SA(input, values))
  #   lapply(0:values$nProbabilistic, function(i){
  #     req(input[[paste0("PSADistrib", i)]])
  #     if (input[[paste0("PSADistrib", i)]] == "Multinomial"){
  #       req(input[[paste0("PSAParam1", i)]])
  #       lapply(seq_len(input[[paste0("PSAParam1", i)]]), function(j){
  #         fluidRow(
  #           column(4, 
  #           if (j == 1) textInput(paste0("PSAMultinomName", i, j), label = "Parameter", value = input[[paste0("PSAGlobalParamName", i)]]) %>% disabled
  #           else  selectInput(paste0("PSAMultinomName", i, j), label = "Parameter", choices = choices, selected = ifelse(!is.null(input[[paste0("PSAMultinomName", i, j)]]), input[[paste0("PSAMultinomName", i, j)]], ""))
  #         ),
  #         column(4, numericInput("PSAMultinomValue", "Value", 0))
  #         )
  #       })
  #     }
  #   })
  # })
  
  output$outInit <- renderUI({
    #####
    req(
      nbState <- ux_nb_states(input),
      stateNames <- ux_state_names(input)
    )
    tagList(
      tags$h3("Initial counts per state"),
      tags$table(
        tagList(
          list(
            tags$th(""),
            tags$th(style='text-align:center', "Count")
          ),
          lapply(
            seq_len(nbState),
            function(i) {
              tags$tr(
                list(
                  tags$td(
                    strong(stateNames[i])),
                  tags$td(
                    if (i == 1) {
                      numericInput(
                        paste0("init", i),
                        label = NULL,
                        value = 1000,
                        width="100%"
                      )
                    } else {
                      numericInput(
                        paste0("init", i),
                        label = NULL,
                        value = 1000,
                        width="100%"
                      )
                    }
                  )
                )
              )
            }
          )
        )
      )
    )
  })
  
  output$outModel <- renderUI({
    #####
    values$model <- ux_run_models(input = input, values = values)
    values$summary_model <- summary(values$model)
    
    if (is.null(values$model)) {
      tagList(tags$h3("Model specification incomplete"))
    } else {
      tagList(
        tags$h1("Model results"),
        tags$h3("Total values")
      )
    }
  })
  
  output$tableResults <- DT::renderDataTable({
    #####
    req(values$model)
    req(values$summary_model$res)
    
    DT::datatable(
      values$summary_model$res,
      options = list(
        searching = FALSE,
        paging = FALSE,
        info = FALSE
      )
    )
  })
  
  output$titleICER <- renderUI({
    #####
    req(values$model)
    req(values$summary_model$res_comp)
    
    tagList(
      tags$h3("Efficiency frontier"),
      tags$p(paste(values$summary_model$frontier, collapse = " -> ")),
      tags$h3("Model comparison")
    )
  })
  
  output$tableICER <- DT::renderDataTable({
    #####
    req(values$model)
    req(values$summary_model$res_comp)
    
    DT::datatable(
      values$summary_model$res_comp,
      options = list(
        searching = FALSE,
        paging = FALSE,
        info = FALSE
      )
    )
  })
  
  output$outCounts <- renderUI({
    #####
    
    req(values$model)
    
    tagList(
      tags$h3("Plot state membership count"),
      selectInput(
        inputId = "modelPlotCounts",
        label = "Model",
        choices = as.vector(ux_model_names(input))
      )
    )
  })
  
  output$plotCounts <- renderPlot({
    #####
    req(values$model)
    model <- input$modelPlotCounts
    req(model)
    plot(
      values$model,
      type = "counts",
      model = model
    ) +
      ggplot2::theme_minimal() +
      ggplot2::scale_colour_brewer(
        name = "State",
        palette = "Set1"
      )
  },
  width = 600)
  
  output$debugParams <- renderUI({
    req(ux_nb_models(input))
    tagList(
      lapply(
        seq_len(ux_nb_models(input)),
        function(x) {
          renderPrint(ux_parameters(input, values, x))
        }
      )
    )
  })
  
  output$debugModels <- renderUI({
    req(ux_nb_models(input))
    tagList(
      lapply(
        seq_len(ux_nb_models(input)),
        function(x) {
          renderPrint(ux_model(
            input = input,
            values = values,
            model_number = x
          ))
        })
    )
  })
  
  output$debugRunModels <- renderPrint({
    ux_run_models_raw(input, values)
  })
  

  ### prepare_timedep has a big problem with reactivity : there are 2 renderUI imbricated inside 1 renderUI. 
  ### When one of the renderUI is updated, all the others are invalidated. 
  
  prepare_timedep <- function(n, edit, input, values) {
      table_body <- tagList(
        column(2, textInput(paste0("timedepName", n), NULL, ifelse(!is.null(input[[paste0("timedepName", n)]]), input[[paste0("timedepName", n)]], ""))),
        column(2, selectInput(paste0("timedepType", n), NULL, choices = c("Constant variation with the number of cycles" = "constant", "Non-constant variation with the number of cycles" = "nonConstant"), selected = ifelse(!is.null(input[[paste0("timedepType", n)]]), input[[paste0("timedepType", n)]], character(0)))),
        column(8, renderUI({
          fluidRow(
          if (!is.null(input[[paste0("timedepType", n)]])){
            if (input[[paste0("timedepType", n)]] == "constant"){
              column(9,
                  renderUI({
                fluidRow(
                  column(4, textInput(paste0("timedepValueC", n), NULL,  isolate(ifelse(!is.null(input[[paste0("timedepValueC", n)]]), input[[paste0("timedepValueC", n)]],""))))
                )
                })
              )
            } else {
              if (is.null(values[[paste0("nTimedepNC", n)]])) {
                values[[paste0("nTimedepNC", n)]] <- 0
              }
              tagList(
                column(9, 
                       renderUI({
                       lapply(0:values[[paste0("nTimedepNC", n)]], function(i){
                             fluidRow(
                               column(4, textInput(paste0("timedepValueNC", n, i), NULL, isolate(ifelse(!is.null(input[[paste0("timedepValueNC", n, i)]]), input[[paste0("timedepValueNC", n, i)]], "")))),
                               column(4, numericInput(paste0("timedepStart", n, i), NULL, isolate(ifelse(!is.null(input[[paste0("timedepStart", n, i)]]), input[[paste0("timedepStart", n, i)]],"")))),
                               column(4, numericInput(paste0("timedepEnd", n, i), NULL, isolate(ifelse(!is.null(input[[paste0("timedepEnd", n, i)]]), input[[paste0("timedepEnd", n, i)]], ""))))
                             )
                           })
                         })
                
                ),
                column(2, actionButton(paste0("timedepNew", n), icon("plus")))
              )
            }
          }
          )
        })
        )
      ) 
      table_title <- tagList(
        column(2, strong("Name")),
        column(2, strong("Type of time-dependent variable")),
        column(8, renderUI({
          fluidRow(
          if (!is.null(input[[paste0("timedepType", n)]])){
            if (input[[paste0("timedepType", n)]] == "constant"){
              column(9,
                     fluidRow(
                      column(4, strong("Value"))
                     )
              )
            } else {
              tagList(
                column(9, 
                  fluidRow(
                    column(4, strong("Value")),
                    column(4, strong("Cycle Start")),
                    column(4, strong("Cycle End"))
                  )
                )
              )
            }
              
          }
          )
        }))
      )
      return(list(title = table_title, body = table_body))
  }
  prepare_rgho <- function(n, edit, input, values) {
    table_body <- tagList(
      isolate(column(2, textInput(paste0("rghoName", n), NULL, ifelse(!is.null(input[[paste0("rghoName", n)]]), input[[paste0("rghoName", n)]], "")))),
      isolate(column(2, textInput(paste0("rghoStartAge", n), NULL, ifelse(!is.null(input[[paste0("rghoStartAge", n)]]), input[[paste0("rghoStartAge", n)]], "")))),
      isolate(column(2, selectInput(paste0("rghoGender", n), NULL, choices = c(Female = "FMLE", Male = "MLE"), selected = input[[paste0("rghoGender", n)]]))),
      column(2, searchRegion(n, input)),
      column(2, renderUI({
        searchCountry(n, input)
        }))
    )
    table_title <- tagList(
      column(2, strong("Name")),
      column(2, strong("Age at beginning")),
      column(2, strong("Gender")),
      column(2, strong("Region")),
      column(2, strong("Country"))
    )
    return(list(title = table_title, body = table_body))
  }
  
  prepare_equation <- function(n, edit, input, values) {
    table_title <- tagList(
      column(2, strong("Name")),
      column(2, strong("Value"))
    )
    table_body <- tagList(
      column(2, textInput(paste0("equationName", n), NULL, ifelse(!is.null(input[[paste0("equationName", n)]]), input[[paste0("equationName", n)]], ""))),
      column(2, textInput(paste0("equationValue", n), NULL, ifelse(!is.null(input[[paste0("equationValue", n)]]), input[[paste0("equationValue", n)]], "")))
    )
    return(list(title = table_title, body = table_body))
  }
  
  prepare_survival <- function(n, edit, input, values) {
   table_body <- tagList(
     column(12,
     renderUI({
       fluidRow(
         column(2, textInput(paste0("survivalName", n), NULL, ifelse(!is.null(input[[paste0("survivalName", n)]]), input[[paste0("survivalName", n)]], ""))),
         column(2, selectInput(paste0("survivalDistribution", n), NULL, choices = c("Exponential", "Weibull"), selected = ifelse (!is.null(input[[paste0("survivalDistribution", n)]]), input[[paste0("survivalDistribution", n)]], ""))),
         column(2, numericInput(paste0("survivalLambda", n), NULL, 
                                isolate(ifelse(!is.null(input[[paste0("survivalLambda", n)]]), input[[paste0("survivalLambda", n)]], "")))),
         column(2, 
                if (!is.null(input[[paste0("survivalDistribution", n)]]) && input[[paste0("survivalDistribution", n)]] == "Weibull"){
                  isolate(numericInput(paste0("survivalK", n), NULL, ifelse(!is.null(input[[paste0("survivalK", n)]]), input[[paste0("survivalK", n)]],"")))
                }
         ))
     })
     )
   )
   table_title <- tagList(
    column(12, 
           fluidRow(
             column(2, strong("Name")), 
             column(2, strong("Distribution")), 
             column(2, strong("Lambda")),
             column(2, renderUI({
               if (!is.null(input[[paste0("survivalDistribution", n)]]) && input[[paste0("survivalDistribution", n)]] == "Weibull"){
                 strong("k")
               }
             }))
           )
    )
   )
   return(list(title = table_title, body = table_body))
  }

  for (module in MODULES){
    edit <- FALSE
    output[[module]] <- renderUI({ # I can't figure out how to use the variable "module" inside the renderUI. I tried parent.env() with no success
      substitute({
        nb_lines <- values[[paste0("n", upFirst(module))]]
        out <- lapply(seq_len(nb_lines) - 1, function(n){
          isolate({
            title_body <- do.call(paste0("prepare_", module), list(n, edit, input, values))
            show_module(module, edit, n, title_body$title, title_body$body)
          })
        })
        out
      })
    }, quoted = TRUE)
  }
  
  output$globalParameters <- renderUI({
    tagList(
    fluidRow(class="dropdown",
             column(12,
                 actionLink("newParam", "", icon("plus-circle", class="fa-3x rotateIcon"), style="margin-bottom:40px") %>% div,
                 hidden(
                   fluidRow(
                     id = "tabnewParam",
                     tags$ul(class = "dropdown-menu", style ="position:absolute; top:0; left:60px; display:block; background-color:rgba(255, 255, 255, 0.8)",
                             lapply(seq_along(MODULES), function(i){
                               tags$li(
                                 actionLink(MODULES[i], names(MODULES)[i], class = "btn btn-link")
                               )
                             })
                     )
                   )
                 )
                 )
             ),
       lapply(MODULES, function(module){
         fluidRow(
           column(12,
                  uiOutput(module)
           )
         )})
    )
  })
  
  onevent(
    "mouseenter",
    "newParam",
    show(
      "tabnewParam",
      anim = F,
      animType = "fade"
    ))
  onevent(
    "mouseleave",
    "globalParameters",
    hide(
      "tabnewParam",
      anim = F,
      animType = "fade"
    ))
  
  lapply(MODULES, function(module) {
    observeEvent(input[[module]], {
      edit = TRUE
      for (mod in MODULES){
          removeUI(paste0("#editing", upFirst(mod)))
      }
      if (module ==  "rgho" && (is.null(REGION) | is.null(COUNTRY))){
        try({
          REGION <<- get_gho_codes(dimension = "REGION")
          COUNTRY <<- get_gho_codes(dimension="COUNTRY")
        })
        if (is.null(REGION) | is.null(COUNTRY)){
          showNotification("GHO server is not reacheable for the moment. Please try again later.", duration = 5, type = "warning")
        }
      }
      else {
        n <- values[[paste0("n", upFirst(module))]]
        title_body <- do.call(paste0("prepare_", module), list(n, edit, input, values))
        insertUI("#addModule", ui=
                 show_module(module, edit, n, title_body$title, title_body$body)
          )
      }
    })
  })

  observeEvent(input$equationOK, {
    removeUI("#editingEquation")
    values$nEquation <- values$nEquation + 1
  })

  observeEvent(input$rghoOK, {
    removeUI("#editingRgho")
    values$nRgho <- values$nRgho + 1
  })

  observeEvent(input$survivalOK, {
    removeUI("#editingSurvival")
    values$nSurvival <- values$nSurvival + 1
  })

  
  observeEvent(input$timedepOK, {
    removeUI("#editingTimedep")
    n <- values$nTimedep
    values$nTimedep <- n + 1
  }) 
})

